Nice — let’s build a small JNI-based example: a native DLL (written in C++) that implements a mathematical operation (I’ll use factorial) and a Java program that calls it. I’ll give you:

Theory / how JNI + DLL works (simple and clear).

Java code (native declaration + tester).

C++ code that implements the JNI function and builds into a DLL.

Full step-by-step build instructions (Windows: Visual C++ and MinGW variants).

Explanation of every line / step and things to watch for.

You can adapt the same pattern to other operations (power, GCD, matrix multiply, etc.).

1) Quick theory (what's happening)

JNI (Java Native Interface) lets Java call native code (C/C++). Use it when you need platform APIs, high performance C/C++ code, or to reuse existing native libraries.

Java declares a method native but has no body. At runtime Java loads a native library (DLL on Windows, .so on Linux) containing the native implementation.

The native function follows a specific signature (generated by javac -h or javah) and receives a JNIEnv* (pointer to JNI API) and either jobject or jclass depending on whether the native method is instance or static.

Typical steps:

Write Java class with native method.

Compile Java and generate C/C++ header (javac -h . ClassName.java).

Implement the C/C++ function using the header signature.

Build the C/C++ code into a shared library/DLL, linking to no special libs (just build).

In Java, call System.loadLibrary("..."), then call the native method.

2) Java code

Create two files:

MathLib.java — declares the native method and loads the library.
TestMathLib.java — tests the native method.

MathLib.java

public class MathLib {
    // native method declaration
    public native long factorial(int n);

    // load the native library (MathLib.dll on Windows)
    static {
        System.loadLibrary("MathLib"); // name without prefix/suffix
    }

    // optional: Java fallback or wrapper
    public long factorialSafe(int n) {
        if (n < 0) throw new IllegalArgumentException("n must be >= 0");
        return factorial(n);
    }
}


TestMathLib.java

public class TestMathLib {
    public static void main(String[] args) {
        MathLib lib = new MathLib();
        int n = 10; // change to test
        long result = lib.factorialSafe(n);
        System.out.println("factorial(" + n + ") = " + result);

        // test a few values
        for (int i = 0; i <= 12; i++) {
            System.out.printf("%2d! = %d%n", i, lib.factorialSafe(i));
        }
    }
}

3) Generate JNI header (from Java)

From command line in the folder with MathLib.java:

javac MathLib.java TestMathLib.java        # compile Java
javac -h . MathLib.java                    # generates header file MathLib.h in current dir


javac -h replaces the old javah tool — it generates a header containing the C function signature you must implement.

This will produce a header file named something like MathLib.h that contains the JNI function prototype, e.g.:

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class MathLib */

#ifndef _Included_MathLib
#define _Included_MathLib
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     MathLib
 * Method:    factorial
 * Signature: (I)J
 */
JNIEXPORT jlong JNICALL Java_MathLib_factorial
  (JNIEnv *, jobject, jint);

#ifdef __cplusplus
}
#endif
#endif

4) C++ implementation (MathLib.cpp)

Create MathLib.cpp in same directory:

#include <jni.h>
#include "MathLib.h"

// simple factorial using 64-bit result; returns -1 on negative input or overflow detection (optional)
JNIEXPORT jlong JNICALL Java_MathLib_factorial(JNIEnv* env, jobject obj, jint n) {
    if (n < 0) {
        // Option: throw exception back to Java
        jclass iae = env->FindClass("java/lang/IllegalArgumentException");
        if (iae != nullptr) env->ThrowNew(iae, "n must be >= 0");
        return (jlong)-1; // won't be used if exception thrown
    }

    jlong result = 1;
    for (int i = 2; i <= n; ++i) {
        // naive overflow detection: check if result * i would overflow jlong
        if (result > (LLONG_MAX / i)) {
            // Throw an ArithmeticException to Java
            jclass ae = env->FindClass("java/lang/ArithmeticException");
            if (ae != nullptr) env->ThrowNew(ae, "Overflow computing factorial");
            return (jlong)-1;
        }
        result *= i;
    }
    return result;
}


Notes:

JNIEXPORT and JNICALL are macros for calling convention/export.

JNIEnv* env allows you to call back into JVM (create/throw exceptions, manipulate objects).

jobject is the Java this reference (since the method is non-static). If native method were static, signature would include jclass.

We throw Java exceptions from native using env->ThrowNew(...) for errors.

5) Build DLL (Windows)
Option A — Visual C++ (Developer Command Prompt)

Open x64 Native Tools Command Prompt for VS if building 64-bit, or the 32-bit prompt for 32-bit. Make sure your JAVA_HOME points to the JDK folder.

Commands:

REM set JAVA_HOME if not set
set JAVA_HOME=C:\Program Files\Java\jdk-17.0.2

cl /I"%JAVA_HOME%\include" /I"%JAVA_HOME%\include\win32" /LD MathLib.cpp /FeMathLib.dll


Explanation:

/I includes the JNI headers directory.

/LD tells cl.exe to create a DLL.

/FeMathLib.dll names output MathLib.dll.

If successful, you get MathLib.dll. Place it either:

in System32 (not recommended), or

in the working directory where you run java, or

add the DLL directory to PATH before running Java.

Option B — MinGW (g++)

If using MinGW 64-bit (mingw-w64), from MSYS2 or Windows CMD:

set JAVA_HOME=C:\Program Files\Java\jdk-17.0.2
g++ -I"%JAVA_HOME%/include" -I"%JAVA_HOME%/include/win32" -shared -o MathLib.dll MathLib.cpp -Wl,--add-stdcall-alias


(Flags vary; on some MinGW setups you may need -Wl,--kill-at or -static-libgcc. The important part is the include path and -shared.)

Important: Build target bitness must match the JVM (32-bit vs 64-bit). If your Java is 64-bit, build a 64-bit DLL.

6) Run the Java test

In the directory with TestMathLib.class and MathLib.dll:

java TestMathLib


Output should show factorials. If Java throws UnsatisfiedLinkError, Java can't find or load the DLL — check PATH and library name. System.loadLibrary("MathLib") expects:

On Windows: MathLib.dll (named exactly).

On Linux/macOS: libMathLib.so / libMathLib.dylib (different naming).

If you get an exception from native (e.g., ArithmeticException), it will propagate to Java.

7) Step-by-step explanation of code & flow

public native long factorial(int n);

Tells Java: this method is implemented in native code (no Java body).

static { System.loadLibrary("MathLib"); }

Loads the native library MathLib when the class loads. If load fails, UnsatisfiedLinkError is thrown.

Compile Java and run javac -h . MathLib.java

Generates header MathLib.h with the exact C/C++ signature matching package & class name.

MathLib.cpp uses the generated signature Java_MathLib_factorial(JNIEnv*, jobject, jint)

JNIEnv* env gives API to throw exceptions or interact with JVM.

jobject is the Java this object.

jint is the C type mapping for Java int. Return type jlong maps to Java long.

Native code computes factorial in a for loop and returns as jlong.

If n < 0 we throw IllegalArgumentException using env->ThrowNew. This signals Java an exception occurred.

Build the native code into a DLL; ensure header include paths point to ${JAVA_HOME}/include and platform-specific header ${JAVA_HOME}/include/win32.

Run Java; Java calls the native function directly (via JNI) and gets back the result.

8) Extra: throwing and catching exceptions across the boundary

In the C++ code we used:

jclass iae = env->FindClass("java/lang/IllegalArgumentException");
env->ThrowNew(iae, "n must be >= 0");


This throws a Java exception — when control returns to Java, the Java code will see the exception (unless native code clears it). So prefer to throw Java exceptions for error conditions.

9) Porting to other operations / languages

Change native method signature and C++ code to implement sum, power, matrix multiply, GCD, etc. Regenerate the header with javac -h every time you change Java native method signatures.

You can also create more functions in one DLL (multiple native methods in one class or in multiple classes).

If you want to use VB or plain VC++ (no JNI), that would produce a standard COM/Win32 DLL — but Java then cannot call it directly unless wrapped by JNI. So JNI C/C++ code is the usual approach.

10) Common issues & debugging

UnsatisfiedLinkError: Java cannot find the DLL. Put the DLL in the working directory or add its folder to PATH. Also confirm library name and that the DLL is built with the same bitness as the JVM.

NoSuchMethodError / wrong signature: If your C++ function signature doesn't match the generated header, Java will fail. Use javac -h to get the correct signature, and copy it exactly (class name and package name affect signature).

64-bit vs 32-bit mismatch: JVM and native library must be same architecture.

Missing JNI headers: Ensure include paths point to the JDK's include and platform include folder.

Runtime exceptions: If native throws, Java receives exceptions. Check logs and use env->ExceptionDescribe() for native-side debugging (not necessary for production).

11) Full example recap (all files)

MathLib.java

public class MathLib {
    public native long factorial(int n);
    static { System.loadLibrary("MathLib"); }
    public long factorialSafe(int n) {
        if (n < 0) throw new IllegalArgumentException("n must be >=0");
        return factorial(n);
    }
}


TestMathLib.java

public class TestMathLib {
    public static void main(String[] args) {
        MathLib lib = new MathLib();
        System.out.println("5! = " + lib.factorialSafe(5));
    }
}


MathLib.cpp

#include <jni.h>
#include "MathLib.h"
#include <climits>

JNIEXPORT jlong JNICALL Java_MathLib_factorial(JNIEnv* env, jobject obj, jint n) {
    if (n < 0) {
        jclass iae = env->FindClass("java/lang/IllegalArgumentException");
        if (iae) env->ThrowNew(iae, "n must be >= 0");
        return -1;
    }
    jlong res = 1;
    for (int i = 2; i <= n; ++i) {
        if (res > LLONG_MAX / i) {
            jclass ae = env->FindClass("java/lang/ArithmeticException");
            if (ae) env->ThrowNew(ae, "Overflow computing factorial");
            return -1;
        }
        res *= i;
    }
    return res;
}


Build steps already shown above.

12) If you want, I can:

Provide a ready-made Visual Studio project .vcxproj file (I can write one out).

Show MinGW commands tuned for your exact JDK version.

Convert this to a static native method (so C signature uses jclass) example.

Replace factorial with another math op (power, GCD, matrix multiply) with full code.

Tell me which one you prefer and I’ll produce that next (no waiting).